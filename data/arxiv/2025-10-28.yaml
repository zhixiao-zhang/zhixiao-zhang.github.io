title: Memory Safety / PL / Systems Radar
description: Recent arXiv papers filtered by my interests in systems security, PL,
  and memory safety.
generated_at: '2025-10-28T16:09:09.478980+00:00'
papers:
- arxiv_id: 2510.23517v1
  title: "Linear effects, exceptions, and resource safety: a Curry-Howard\n  correspondence\
    \ for destructors"
  authors:
  - Sidney Congard
  - Guillaume Munch-Maccagnoni
  - Rémi Douence
  summary: "We analyse the problem of combining linearity, effects, and exceptions,\
    \ in\nabstract models of programming languages, as the issue of providing some\
    \ kind\nof strength for a monad $T(- \\oplus E)$ in a linear setting. We consider\
    \ in\nparticular for $T$ the allocation monad, which we introduce to model and\
    \ study\nresource-safety properties. We apply these results to a series of two\
    \ linear\neffectful calculi for which we establish their resource-safety properties.\n\
    \  The first calculus is a linear call-by-push-value language with two\nallocation\
    \ effects $\\mathit{new}$ and $\\mathit{delete}$. The resource-safety\nproperties\
    \ follow from the linear (and even ordered) character of the typing\nrules.\n\
    \  We then explain how to integrate exceptions on top of linearity and effects\n\
    by adjoining default destruction actions to types, as inspired by C++/Rust\ndestructors.\
    \ We see destructors as objects $\\delta : A\\rightarrow TI$ in the\nslice category\
    \ over $TI$. This construction gives rise to a second calculus, an\naffine ordered\
    \ call-by-push-value language with exceptions and destructors, in\nwhich the weakening\
    \ rule performs a side-effect. As in C++/Rust, a ``move''\noperation is necessary\
    \ to allow random-order release of resources, as opposed\nto last-in-first-out\
    \ order. Moving resources is modelled as an exchange rule\nthat performs a side-effect."
  tldr: '- Addresses the challenge of combining linear types, effects (like resource
    allocation/deallocation), and exceptions while preserving resource safety guarantees
    in programming languages.

    - Uses a monadic framework with destructors (inspired by C++/Rust) that trigger
    automatic cleanup actions, modeling moves and exceptions through side-effecting
    type system rules.

    - Ensures resources like memory are never leaked even when exceptions occur, directly
    improving memory safety and reliability in low-level systems programming.'
  ai_score: 8
  ai_reason: The paper's focus on linear type systems, resource safety, destructors
    inspired by C++/Rust, and formal semantics directly addresses memory/temporary/spatial
    safety, type systems, and program analysis from the researcher's focus areas.
  updated: '2025-10-27T16:56:44Z'
  published: '2025-10-27T16:56:44Z'
  pdf_url: http://arxiv.org/pdf/2510.23517v1
  primary_category: cs.PL
  categories:
  - cs.PL
  - cs.LO
- arxiv_id: 2510.23487v1
  title: "Are Agents Just Automata? On the Formal Equivalence Between Agentic AI\n\
    \  and the Chomsky Hierarchy"
  authors:
  - Roham Koohestani
  - Ziyou Li
  - Anton Podkopaev
  - Maliheh Izadi
  summary: 'This paper establishes a formal equivalence between the architectural
    classes

    of modern agentic AI systems and the abstract machines of the Chomsky

    hierarchy. We posit that the memory architecture of an AI agent is the

    definitive feature determining its computational power and that it directly

    maps it to a corresponding class of automaton. Specifically, we demonstrate

    that simple reflex agents are equivalent to Finite Automata, hierarchical

    task-decomposition agents are equivalent to Pushdown Automata, and agents

    employing readable/writable memory for reflection are equivalent to TMs. This

    Automata-Agent Framework provides a principled methodology for right-sizing

    agent architectures to optimize computational efficiency and cost. More

    critically, it creates a direct pathway to formal verification, enables the

    application of mature techniques from automata theory to guarantee agent safety

    and predictability. By classifying agents, we can formally delineate the

    boundary between verifiable systems and those whose behavior is fundamentally

    undecidable. We address the inherent probabilistic nature of LLM-based agents

    by extending the framework to probabilistic automata that allow quantitative

    risk analysis. The paper concludes by outlining an agenda for developing static

    analysis tools and grammars for agentic frameworks.'
  tldr: '- Addresses the inability to formally verify the safety and predictability
    of AI agents due to their undefined computational power boundaries.

    - Maps agent memory architectures to automata classes: reflex agents to finite
    automata, hierarchical agents to pushdown automata, and reflective agents to Turing
    machines.

    - Enables formal verification of agent behavior, allowing security guarantees
    for memory-safe agent designs and risk quantification for undecidable systems.'
  ai_score: 7
  ai_reason: The paper's focus on formal verification, safety guarantees, static analysis
    tools, and memory architecture directly connects to program analysis, formal semantics,
    and memory safety aspects of the researcher's interests.
  updated: '2025-10-27T16:22:02Z'
  published: '2025-10-27T16:22:02Z'
  pdf_url: http://arxiv.org/pdf/2510.23487v1
  primary_category: cs.AI
  categories:
  - cs.AI
  - cs.FL
- arxiv_id: 2510.23211v1
  title: "Proceedings of the Combined 32nd International Workshop on\n  Expressiveness\
    \ in Concurrency and 22nd Workshop on Structural Operational\n  Semantics"
  authors:
  - Cinzia Di Giusto
  - Giorgio Bacci
  summary: 'This volume contains the proceedings of EXPRESS/SOS 2025: the Combined
    32nd

    International Workshop on Expressiveness in Concurrency and the 22nd Workshop

    on Structural Operational Semantics, which was held in Aarhus, Denmark, as an

    affiliated workshop of CONFEST 2025. The EXPRESS/SOS workshop series aims at

    bringing together researchers interested in the formal semantics of systems and

    programming concepts, and in the expressiveness of computational models.'
  tldr: '- This is a workshop proceedings, not a research paper addressing a specific
    security problem or presenting a technical method.

    - It contains multiple papers on formal semantics and concurrency theory rather
    than proposing a single security mechanism.

    - Understanding formal semantics matters for memory safety as it provides mathematical
    foundations for verifying correctness of low-level systems and concurrent programs.'
  ai_score: 7
  ai_reason: The paper's focus on formal semantics and computational models directly
    aligns with the researcher's interests in formal semantics, program analysis,
    and type systems.
  updated: '2025-10-27T11:01:38Z'
  published: '2025-10-27T11:01:38Z'
  pdf_url: http://arxiv.org/pdf/2510.23211v1
  primary_category: cs.LO
  categories:
  - cs.LO
  - cs.FL
- arxiv_id: 2510.23101v1
  title: "Beyond Imprecise Distance Metrics: LLM-Predicted Target Call Stacks for\n\
    \  Directed Greybox Fuzzing"
  authors:
  - Yifan Zhang
  - Xin Zhang
  summary: 'Directed greybox fuzzing (DGF) aims to efficiently trigger bugs at specific

    target locations by prioritizing seeds whose execution paths are more likely to

    mutate into triggering target bugs. However, existing DGF approaches suffer

    from imprecise probability calculations due to their reliance on complex

    distance metrics derived from static analysis. The over-approximations inherent

    in static analysis cause a large number of irrelevant execution paths to be

    mistakenly considered to potentially mutate into triggering target bugs,

    significantly reducing fuzzing efficiency. We propose to replace static

    analysis-based distance metrics with precise call stack representations. Call

    stacks represent precise control flows, thereby avoiding false information in

    static analysis. We leverage large language models (LLMs) to predict

    vulnerability-triggering call stacks for guiding seed prioritization. Our

    approach constructs call graphs through static analysis to identify methods

    that can potentially reach target locations, then utilizes LLMs to predict the

    most likely call stack sequence that triggers the vulnerability. Seeds whose

    execution paths have higher overlap with the predicted call stack are

    prioritized for mutation. This is the first work to integrate LLMs into the

    core seed prioritization mechanism of DGF. We implement our approach and

    evaluate it against several state-of-the-art fuzzers. On a suite of real-world

    programs, our approach triggers vulnerabilities $1.86\times$ to $3.09\times$

    faster compared to baselines. In addition, our approach identifies 10 new

    vulnerabilities and 2 incomplete fixes in the latest versions of programs used

    in our controlled experiments through directed patch testing, with 10 assigned

    CVE IDs.'
  tldr: '- Problem: Directed greybox fuzzers waste time on irrelevant execution paths
    due to imprecise static analysis-based distance metrics that over-approximate
    mutation probabilities.


    - Method: Uses LLMs to predict vulnerability-triggering call stacks from static
    call graphs, then prioritizes seeds whose execution paths overlap most with these
    precise call sequences.


    - Impact: Achieves 1.86x–3.09x faster vulnerability triggering in real programs
    and found 10 new CVEs, demonstrating concrete improvements in fuzzing efficiency
    and memory safety bug discovery.'
  ai_score: 7
  ai_reason: The paper's focus on improving fuzzing efficiency through precise call
    stack analysis and program analysis techniques aligns with the researcher's interests
    in program analysis and memory safety, though it has limited direct connection
    to type systems and formal semantics.
  updated: '2025-10-27T08:17:03Z'
  published: '2025-10-27T08:17:03Z'
  pdf_url: http://arxiv.org/pdf/2510.23101v1
  primary_category: cs.CR
  categories:
  - cs.CR
  - cs.PL
  - cs.SE
- arxiv_id: 2503.19447v2
  title: 'Anvil: A General-Purpose Timing-Safe Hardware Description Language'
  authors:
  - Jason Zhijingcheng Yu
  - Aditya Ranjan Jha
  - Umang Mathur
  - Trevor E. Carlson
  - Prateek Saxena
  summary: 'Expressing hardware designs using hardware description languages (HDLs)

    routinely involves using stateless signals whose values change according to

    their underlying registers. Unintended behaviours can arise when the stored

    values in these underlying registers are mutated while their dependent signals

    are expected to remain constant across multiple cycles. Such timing hazards are

    common because, with a few exceptions, existing HDLs lack abstractions for

    values that remain unchanged over multiple clock cycles, delegating this

    responsibility to hardware designers. Designers must then carefully decide

    whether a value should remain unchanged, sometimes even across hardware

    modules. This paper proposes Anvil, an HDL which statically prevents timing

    hazards with a novel type system. Anvil is the only HDL we know of that

    guarantees timing safety, i.e., absence of timing hazards, without sacrificing

    expressiveness for cycle-level timing control or dynamic timing behaviours.

    Unlike many HLS languages that abstract away the differences between registers

    and signals, Anvil''s type system exposes them fully while capturing the timing

    relationships between register value mutations and signal usages to enforce

    timing safety. This, in turn, enables safe composition of communicating

    hardware modules by static enforcement of timing contracts that encode timing

    constraints on shared signals. Such timing contracts can be specified

    parametric on abstract time points that can vary during run-time, allowing the

    type system to statically express dynamic timing behaviour. We have implemented

    Anvil and successfully used it to implement key timing-sensitive modules,

    comparing them against open-source SystemVerilog counterparts to demonstrate

    the practicality and expressiveness of the generated hardware.'
  tldr: '- Addresses timing hazards in hardware design caused by unintended signal
    value changes during multi-cycle operations, a common source of critical bugs
    in digital circuits.

    - Uses a type system that statically enforces timing contracts between register
    mutations and signal usages, preventing unsafe value changes without sacrificing
    cycle-level timing control.

    - Eliminates a major class of hardware vulnerabilities by ensuring timing safety
    across module boundaries, directly preventing erratic behavior that could compromise
    system reliability and security.'
  ai_score: 7
  ai_reason: The paper's novel type system for statically preventing timing hazards
    in hardware description languages directly relates to type systems, formal semantics,
    and program analysis from the researcher's focus areas, though it addresses hardware
    timing safety rather than software memory safety.
  updated: '2025-10-27T04:57:34Z'
  published: '2025-03-25T08:37:45Z'
  pdf_url: http://arxiv.org/pdf/2503.19447v2
  primary_category: cs.AR
  categories:
  - cs.AR
  - cs.PL
  - B.5.2; D.3.1
